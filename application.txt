------------------------------------------------------------------
第4期サイボウズ・ラボユース応募用紙
------------------------------------------------------------------
氏名（ふりがな）：
生年月日：
現住所：
最寄駅：
電話番号：
E-mail アドレス：
Twitter ID：
ブログ URL：

保護者氏名（ふりがな）：
実家住所：
緊急連絡先：

学歴：
○○年3月　○○中学校　卒業
○○年4月　○○高等学校○○科　入学
○○年3月　○○高等学校○○科　卒業
○○年4月　○○大学○○学部○○学科　入学

試験期間：
------------------------------------------------------------------
今年度、学校で予定されている試験の日程をお書きください。
------------------------------------------------------------------
1学期　中間試験：○○年○月○日～○○年○月○日まで
1学期　期末試験：○○年○月○日～○○年○月○日まで
2学期　中間試験：○○年○月○日～○○年○月○日まで
2学期　期末試験：○○年○月○日～○○年○月○日まで
（未就業者の方は未記入で構いません。）

希望時期：
------------------------------------------------------------------
サイボウズ・ラボに来社可能な時期をお書きください。
------------------------------------------------------------------
・○月○日以降の毎週○曜日の○時～○時まで（○学期の期間）
《記入例》
・夏休みの8月～9月、春休みの3月のうち週1～3日程度を希望
・6月以降の水曜日15時以降。夏休みと春休みは週2日程度を希望
《基本条件》
・平日10:00～18:00までの間で任意の時間帯（休憩1時間）に
　サイボウズ・ラボのオフィスで開発作業していただきます。
≪遠隔地の方≫
・在宅での作業を別途希望される場合の条件をお書きください。

研究対象テーマ：
------------------------------------------------------------------
サイボウズ・ラボユースで取り組んでみたいテーマを選択してください。
------------------------------------------------------------------
□自然言語処理、機械学習、全文検索
□Webセキュリティ、脆弱性発見
□データベース技術、Linuxカーネル開発
□プログラミング言語処理系・VMの開発
□オープンソースソフトウェアの開発
□その他

              （選択したテーマを □ から ■ に変更してください。）

得意なプログラミング言語：
------------------------------------------------------------------
今、あなたが使えるプログラミング言語と好きなところをお書き下さい。
------------------------------------------------------------------
○○言語（中学○年生の頃から）

自己アピール：
------------------------------------------------------------------
あなたのアピールポイントを自由にお書き下さい。（字数・形式無制限）
------------------------------------------------------------------

0. 背景
=======

%
% I. プログラミングコンテストとの出会いについて
%

私は2009年に開催された "パソコン甲子園" という高校生を対象とした
プログラミングコンテストへの参加を契機に "Codeforces" や "Google
Code Jam" などオンラインで定期的に開催されているプログラミング
コンテストにしばしば参加しています。これまでに私がプログラミング
コンテストに参加した回数は250回を超えており、練習で解いた問題を
含めると1400問以上のアルゴリズム実装に関する問題を解きました。

私が高校生のときにパソコン甲子園に参加したのは、自分で立ち上げた
同好会に何か活動実績を残すのが目的でしたが、運良く予選を通過する
ことができたため全国大会に向けて練習をする必要がありました。

それから、ある掲示板サイトで "TopCoder" という海外のプログラミング
コンテストがオンラインで頻繁に開催されているという情報を得て、
練習のために過去問を解いてみることにしました。

英語で書かれた問題文を読み解き、自分の解釈を元に解答の方針を立て、
解答となるソースコードを書いて提出し、その結果について正解か
不正解かを自動的に判定してもらえるのは、プログラミングの練習という
よりも英文読解の練習において非常に有効であると感じられました。
なぜならプログラミング言語という世界共通の言語を通して、自分の
解釈の良し悪しを判断することができるからです。

当時は "Win32" や "DirectX" などの API を利用した Windows
アプリケーションのプログラミングに興味があり、ドキュメントである
"MSDN" をよく読んでいました。しかし、日本語に翻訳されていない
コンテンツに当たったときに、英文で書かれている情報が読めなかった
ため、英文読解力をつけたいという気持ちを強く持っていました。
そのため、海外のプログラミングコンテストの問題を解き、英語の
学習につなげることが、大会以降もプログラミングコンテストに
参加し続ける強い動機となりました。


%
% II. プログラミングコンテストにおけるライブラリ事情とその問題点
%

% A. 国内のライブラリ事情

プログラミングコンテストで解答を提出するときは、1つの問題に対して
解答となる1つのソースファイルを提出するという形式が一般的です。
また、プログラムを実行して採点するような形式のプログラミング
コンテストでは、一般的に標準ライブラリ以外のライブラリファイルの
使用は認められていません。そのため、競技者は各自が用意した
ライブラリをコピーしたり直接書き写すことによって1つのソース
ファイルにまとめる必要があります。

プログラミングコンテストにおける「ライブラリ」は、テンプレート
もしくはスニペットのように断片的なテキスト形式として利用できる
必要があり、一般的なプログラミングにおけるライブラリと比べると、
その在り方が限定されているのが特徴です。

日本国内におけるプログラミングコンテスト用のライブラリとして
有名なものに "Spaghetti Source" があります。これは "ICPC"
という大学対抗のプログラミングコンテストで出題される問題を解く
ために必要な各種アルゴリズムを C++ で実装したソースコードを
公開しているウェブサイトで、個人が公開しています。

ICPC では、競技中にインターネット上の情報を参考にして問題を
解くことは禁止されていますが、書籍や印刷物を持ち込んで閲覧する
ことは許可されているため、参加者は大会で使用するライブラリを
事前に紙に印刷して持ち込んでいます。例年、一部の参加者が大会
終了後に各自のライブラリをインターネット上で公開しています。

2009年に発売された "プログラミングコンテストチャレンジブック"
という書籍はプログラミングコンテストで使用する典型的なアルゴリズム
実装を例題付きで分かり易くまとめあげたもので、広く話題となり
プログラミングコンテストの知名度を高めました。この書籍もライブラリ
として活用している人を多く見かけます。


% B. 問題点 - テスト手法

上記のライブラリは、いずれも断片的なソースコードのみを公開して
いるため、テストが十分になされているのか分からず、信頼性を十分に
保証できていません。

これらのライブラリをテストするための手法としては、オンライン
ジャッジと呼ばれるプログラミングコンテスト練習用のシステムを使い、
それらのライブラリを利用する問題を解いてソースコードを送信し、
正解と判定されるかどうかを確認するという古典的方法があります。
例えば、前述した Spaghetti Source では、検証に利用した問題の
リストが記載されています。

アルゴリズム実装におけるテストは、テストケースを考える部分に
難しさがあります。そのため、オンラインジャッジにある問題集を
アルゴリズム実装の信頼性を測るために利用するのは、問題に不備が
ある場合を考慮し、複数の問題を使って多角的にテストを行うことが
できれば十分に信頼できる適切な方法だと思います。

しかし、実際はそのようにコードを再利用することを考えずに問題を
解くため、大抵の場合は問題を解き直す手間が発生してしまいます。


% C. 問題点 - ライブラリのオープンソースプロジェクト化

個人や少人数によって開発されているプログラミングコンテスト用の
ライブラリは上記を含め多数ありますが、オープンソースプロジェクトと
してコミュニティにより継続的に改善がなされているものはありません。

その要因として「ライブラリを配布するための基盤」が存在しないことが
挙げられます。例えば開発者がライブラリを公開し、ユーザーがそれを
ダウンロードして各自の環境で利用することができるような仕組みが
整備されていません。

これはプログラミングコンテストのライブラリ事情が特殊であり、
テキスト形式の断片的なソースコードとして配布する必要があること、
そしてユーザーごとに異なる環境でも利用できる形式としてファイルを
システムに展開することが難しいことに起因していると考えています。


1. 目的
=======

サイボウズ・ラボユースでは大きく2つのシステムを開発したいと思って
います。以下はそれらの簡単な説明とその開発目的など。各システムの
詳細（機能概要）は後述してあります。


%
% I. ソーシャルスニペットシステム
%

各種開発環境やエディタから横断的に利用できるスニペットシステムで、
バックエンドのコマンドライン API とそのフロントエンドである各種
環境の拡張機能やプラグインを開発します。

また、スニペットを配布するためのレジストラは、"GitHub" などの
外部サービスを補助的なインフラとして利用することを考えており、
これが「ソーシャルスニペット」という名前の所以になります。


%
% II. オンラインジャッジをテストケースとして再利用するシステム
%

ソーシャルスニペットシステムを使って、テストケースとして
オンラインジャッジの問題集を利用し、プログラミングコンテスト用の
ライブラリを自動的にテストするための仕組みを提供します。


%
% III. 開発目的
%

ソーシャルスニペットシステムはライブラリをスニペットという形式で
配布するためのシステムです。ここでのスニペットは主に別のソース
コードに埋め込むことが可能な断片的なソースコード、その中でも特に
プログラミングコンテストでの利用を想定したものを指しています。

ソーシャルスニペットシステムでは、スニペットの集まりをリポジトリ
という単位で扱います。開発者はライブラリをリポジトリにまとめる
ことでユーザーにライブラリを配布することができるようになります。
逆に、ユーザーはリポジトリを検索してインストールするだけで各自の
環境でライブラリを利用することができます。

このように、ライブラリを公開するときの指針としてソーシャル
スニペットを機能させることで、プログラミングコンテストの
ライブラリ事情を改善する目的があります。

具体的な改善の1つとして、ソーシャルスニペットシステムとオンライン
ジャッジを組み合わせることで、プログラミングコンテスト用の
ライブラリを自動的にテストすることができるようになります。

ほかには、オンラインジャッジの豊富な問題集をプログラミング
コンテストの練習以外の目的で活用するという狙いもあります。



2. 概要
=======

%
% I. ソーシャルスニペットシステムについて
%    （開発目標と動作イメージ）
%

% A. 開発の目標

どの環境でも利用できて、エディタやファイルシステムなどに依存しない
こと。また、どのプログラミング言語でも利用できることを目標に開発を
進めていきます。


% B. スニペットの挿入機能（相対パス指定）

スニペットファイルの指定にはコメントを利用します。

例えば snip_func 関数を含むソースファイル snip_func.c があり、

```
// snip_func.c
void snip_func() {
  // 処理
}
```


同一ディレクトリに、以下のようなソースファイル code.c があるとき、

```
// code.c
#include <stdio.h>

// @snip <./snip_func.c>

int main() {
  snip_func();
  return 0;
}
```


snip_func.c は code.c に対して以下のように挿入されます。

```
// code.c
#include <stdio.h>

// @snippet <./snip_func.c>
// snip_func.c
void snip_func() {
  // 処理
}

int main() {
  snip_func();
  return 0;
}
```


% C. スニペットの挿入機能（リポジトリ利用）

相対パスによる指定のほか、ローカルにインストールされている
リポジトリに含まれるスニペットを指定することができます。

```
// @snip <repo_name:path/to/file_name>
```

このように記述したときは repo_name リポジトリに含まれる
path/to/file_name ファイルをスニペットとして挿入します。

後述するリポジトリインストール用コマンドを実行して対象となる
リポジトリをローカルにキャッシュしたあと、キャッシュされた
リポジトリにあるファイルから情報を取得します。


% D. スニペットの挿入機能（リポジトリのバージョン指定）

リポジトリはバージョン情報を持ちます。以下のように記述すると、
指定バージョンのスニペットを挿入することができます。

```
// @snip <repo_name#0.0.1:path/to/file_name>
// @snip <repo_name#1.2.x:path/to/file_name>
```


% E. コマンドライン API

// スニペットの挿入・スニペット間の依存関係解決

    $ snip resolve {file_name}

file_name ファイルに含まれるスニペットをすべて挿入します。
挿入するスニペットがスニペットを持つときはそのスニペットも
再帰的に挿入されます。


// リポジトリのインストール

    $ snip install {repo_name}

レジストラに登録されているリポジトリの一覧から、repo_name に
一致するリポジトリをローカルにインストールします。そして、
リポジトリが依存しているリポジトリも同時にインストールされます。


// レジストラにリポジトリを公開（開発者用）

    $ snip publish {name} {URL}

ライブラリ開発者がリポジトリを公開するためのコマンドです。URL には
GitHub リポジトリなどの URL を記述します。指定した URLにある
リポジトリが、指定された名前でレジストラに登録されます。


// レジストラからリポジトリを削除（開発者用）

    $ snip unpublish {name}

レジストラからリポジトリを削除するためのコマンドです。削除するには
リポジトリの所有者であることを示す必要があり、GitHub の場合であれば
オーナーかコラボレーターの権限が必要となります。


// リポジトリの検索

    $ snip search {keyword}

keywordにマッチするリポジトリを検索します。


// リポジトリパスの補完

    $ snip complete {keyword}

リポジトリのパスを補完するための情報を取得するコマンドです。


% F. 各種開発環境の拡張機能・プラグイン

フロントエンドは3種類の環境を最初にサポートします。

* Eclipse
* Emacs
* Vim

基本的な共通機能として以下の2機能を実装します。

* コマンドライン API の呼び出し
* スニペットのパスを記述するときの自動補完

環境に依存すると思われる機能では、以下2種類の機能を検討しています。

* リポジトリの管理
  * 各リポジトリに含まれるファイルをツリー形式で表示できる機能
* 対話式のスニペット挿入
  * テンプレート的なスニペットで関数名や変数名を指定できる機能


% G. レジストラについて

リポジトリを配布するためのシステムです。コマンドライン API からの
問い合わせを受ける Web API とブラウザ上でリポジトリの情報を
参照できる Web サービスから構成されます。

これらの機能として、以下のものがあります:

* リポジトリの追加
* リポジトリの削除
* リポジトリ情報の参照
* リポジトリの検索

リポジトリは誰でも追加することができます。追加するリポジトリの
所有者である必要はありません。誰でも自由に追加することができます。
このとき、リポジトリの名前については早いもの勝ちとなります。

GitHub にある repo リポジトリをレジストラに登録する例:

    $ snip publish user-repo git://github.com/user/repo.git

登録されたリポジトリの削除はリポジトリ所有者とレジストラ管理者
のみが行えるものとします。リポジトリの所有者判定については、
GitHub の API を利用して確認を行います。


% H. リポジトリの特殊ファイル: snippet.json

snippet.json はリポジトリにおいて、そのメタ情報
（名前やプログラミング言語）を記述するためのファイルになります。


記述例:

```
{
  "name": "My Snippet",
  "version": "0.0.1",
  "language": "C++",
  "source_dir": "source"
}
```


% I. リポジトリの特殊ファイル: Snipfile

Snipfile は依存するリポジトリやレジストラを記述するファイルです。
レジストラを指定すると、そのレジストラが提供する情報を元に
リポジトリがインストールされます。

レジストラの指定は以下のように行います:

    source {レジストラのURL}


また、リポジトリの指定は以下のように行います:

    snip {リポジトリ名}, {バージョン指定}


記述例:

```
source "http://url/to/registry"

snip "math", "1.2.3"
snip "geometry", ">=0.0.1"
snip "graph", "3.0.x"
snip "text", "*"
snip "search", "latest"
```



% J. リポジトリのディレクトリ構成例

デフォルトの構成:

```
repo/ （ルート）
 |
 |- snippet.json
 |- Snipfile
 |- file1.c
 -- file2.c
```


snippet.json によってソースディレクトリを変更した場合:

```
repo/ （ルート）
 |
 |- snippet.json
 |- Snipfile
 -- source/ （ソース）
     |- file1.c
     -- file2.c
```


% K. キャッシュされたリポジトリのディレクトリ構成例

バージョンごとにファイルを保存します。

```
{ホームディレクトリなど}/.social_snippet/cache/
 |
 -- repo1/
     |
     |- 0.0.1/
     |   |
     |   |- snippet.json
     |   |- Snipfile
     |   -- file1.c
     |
     -- 0.1.1/
         |
         |- snippet.json
         |- Snipfile
         -- new_file1.c
```


% L. 補助的なインフラについて

レジストラは snippet.json ファイルに含まれるリポジトリのメタ
情報のみを保持し、ファイルは GitHub などの外部サービスを利用して
配布します。GitHubのように所有者確認が可能な外部サービスに
対応していきます。



%
% II. オンラインジャッジをテストケースとして再利用するシステム
%

% A. 目標

なるべく多くのオンラインジャッジに対応し、テスト可能な
アルゴリズム実装の幅を広げ、テストの信頼性を高めていくことを
目指します。


% B. 特筆すべき点

このテストシステムにおいて特筆すべき点として、ライブラリの
ユーザーがそのままテスターとなりうるエコシステムが挙げられます。
ユーザーは普段と同じようにライブラリを利用して問題を解くだけで、
そのコードをテストコードとして開発者に提供することが可能です。


% C. このシステムを利用してライブラリをテストするときの流れ

1. テストしたいライブラリ（ソーシャルスニペット形式）を使い、
   通常と同じようにオンラインジャッジの問題を解く
2. ソースコードをスニペットを挿入する前の状態に戻す
3. ライブラリのテストコードとオンラインジャッジの問題IDを紐付ける
4. スニペットの挿入を実行し、オンラインジャッジにソースコードを送信
5. オンラインジャッジによる正誤判定の結果をテスト結果として表示
6. 指定されたすべての問題に正解できたらテストが成功したとみなす


% D. 課題: オンラインジャッジを匿名で利用できるようにする必要がある

このシステムでは、実際にテストコードをオンラインジャッジへ提出し、
テストの実行と正誤判定をオンラインジャッジに委ね、その結果を
集約することでテストを行います。

基本的にオンラインジャッジというのは登録制のシステムで、認証を
行わずにシステムを利用できるオンラインジャッジは一般的では
ありません。そのため、このシステムを実現するには各オンライン
ジャッジに対応を依頼する必要があります。

ユーザーにオンラインジャッジのアカウントを取得してもらい、
認証情報を各自で設定してもらうことも出来ますが、"Travis CI" や
"Circle CI" のような継続的インテグレーション用のサービスを
利用する場合を考えると、ユーザーが余計な認証情報を設定する
ことなく自由な環境で実行できるようにしたいと考えています。

幸いなことに、私が所属している研究室では "Aizu Online Judge"
（通称 AOJ）というオンラインジャッジを開発しており、必要となる
変更を私自身が担当して行うことができます。AOJ は10年近い稼働実績が
あるほか、収録問題数も国内では最大規模であり、システムのサポート
対象としても申し分ありません。

AOJ 以外のオンラインジャッジへ対応を広げるための戦略として、
まず AOJ への対応によって実用性を示したうえで、国内の
他オンラインジャッジに協力を依頼し、最終的に海外のオンライン
ジャッジへと対応を展開していくことを考えています。


% E. AOJ を匿名提出機能に対応させる場合

AOJ に専用の Web API を追加することで、匿名によるソースコードの
提出に対応させます。既存の提出機能との違いは以下の3つです:

* 認証情報が不要であること
* 正誤判定後に解答ステータスだけを何らかの形式（JSONなど）で返す
* コード提出後に正解数ランキング等の情報に影響を与えないこと

他オンラインジャッジにも同様の提案を行いますが、この機能への
対応についてはオンラインジャッジに導入する直接的なメリットが
思いつかないため、対応を広げるには何らかの形でオンラインジャッジに
還元できる方法を探ることが課題となります。


% F. 対応する候補として考えているオンラインジャッジシステム

以下に挙げたシステム以外にも多くのオンラインジャッジが存在
しますが、ここではフットワークの軽そうなオンラインジャッジを
候補として挙げています。


// 国内のオンラインジャッジ

* Aizu Online Judge
  * ICPC の過去問題などが収録されています
  * 問題数: 1389問

* AtCoder
  * 定期的にプログラミングコンテストを開催しています
  * 問題数: 約300問（過去に開催されたコンテスト1回あたり4問で概算）

* NPCA Judge
  * 灘校パソコン研究部が開発しているオンラインジャッジです
  * 問題数: 約200問（問題IDから概算）


// 海外のオンラインジャッジ

* Sphere Online Judge
  * ポーランドのオンラインジャッジです
  * 問題数: 4952問（ウェブサイト上で公表されている問題数）

* Codeforces
  * ロシアのプログラミングコンテストです
  * 問題数: 約1250問（過去に開催されたコンテスト1回あたり5問で概算）


% G. 各種テストフレームワークへの対応

各種テストフレームワークの拡張機能を提供することで、様々な
プログラミング言語でテストコードとオンラインジャッジの問題を
対応付けることができます。

具体的には Ruby のテストフレームワークである "RSpec" への
対応などを考えており、以下のようにテストの実行を記述できる
ようにしたいと考えています。

```
context :tested_library do
  before do
    snip_mock "tested_library", "../source_dir"
  end
  context :tested_func1 do
    it { aoj "1234", "test_1234.c" }
    it { aoj "777", "test_777.c" }
  end
end
```

上記のテストコードは、tested_library というライブラリに
含まれる tested_func1 という関数をテストするために、 AOJ の
問題番号 1234 に対して "test_1234.c" というファイルを、問題番号
777 に対して "test_777.c" というファイルを解答コードとして
送信することを表しています。

解答を送信する直前にスニペットの挿入が行われますが、ここでは
snip_mock という命令によって、tested_library というリポジトリの
ディレクトリパスを直接指定しテスト対象となる開発版のスニペット
コードが挿入されるように設定しています。



3. 参考
=======

%
% A. プログラミングコンテストの問題セットの作成を補助するツール
%

以下はプログラミングコンテストの問題を作成するためのツールであり、
模範解答となる正誤判定用のプログラムの実行、入力データの生成、
入出力データを検証するための機能などを持っています。

* rime: http://nya3jp.github.io/rime/
* testlib: https://code.google.com/p/testlib/

%
% B. パッケージ管理システム
%

ソーシャルスニペットシステムのレジストラとそのインフラ部分は、
以下のパッケージ管理システムに影響を受けています。

* bower: http://bower.io/
* rubygems: https://rubygems.org/
* npmjs: https://www.npmjs.org/



過去に作成したソフトウェア：
------------------------------------------------------------------
今までどのようなソフトウェアを作成したか自由にお書きください。
------------------------------------------------------------------
GitHubのURLなど：
