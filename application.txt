------------------------------------------------------------------
第4期サイボウズ・ラボユース応募用紙
------------------------------------------------------------------
氏名（ふりがな）：
生年月日：
現住所：
最寄駅：
電話番号：
E-mail アドレス：
Twitter ID：
ブログ URL：

保護者氏名（ふりがな）：
実家住所：
緊急連絡先：

学歴：
○○年3月　○○中学校　卒業
○○年4月　○○高等学校○○科　入学
○○年3月　○○高等学校○○科　卒業
○○年4月　○○大学○○学部○○学科　入学

試験期間：
------------------------------------------------------------------
今年度、学校で予定されている試験の日程をお書きください。
------------------------------------------------------------------
1学期　中間試験：○○年○月○日～○○年○月○日まで
1学期　期末試験：○○年○月○日～○○年○月○日まで
2学期　中間試験：○○年○月○日～○○年○月○日まで
2学期　期末試験：○○年○月○日～○○年○月○日まで
（未就業者の方は未記入で構いません。）

希望時期：
------------------------------------------------------------------
サイボウズ・ラボに来社可能な時期をお書きください。
------------------------------------------------------------------
・○月○日以降の毎週○曜日の○時～○時まで（○学期の期間）
《記入例》
・夏休みの8月～9月、春休みの3月のうち週1～3日程度を希望
・6月以降の水曜日15時以降。夏休みと春休みは週2日程度を希望
《基本条件》
・平日10:00～18:00までの間で任意の時間帯（休憩1時間）に
　サイボウズ・ラボのオフィスで開発作業していただきます。
≪遠隔地の方≫
・在宅での作業を別途希望される場合の条件をお書きください。

研究対象テーマ：
------------------------------------------------------------------
サイボウズ・ラボユースで取り組んでみたいテーマを選択してください。
------------------------------------------------------------------
□自然言語処理、機械学習、全文検索
□Webセキュリティ、脆弱性発見
□データベース技術、Linuxカーネル開発
□プログラミング言語処理系・VMの開発
□オープンソースソフトウェアの開発
□その他

              （選択したテーマを □ から ■ に変更してください。）

得意なプログラミング言語：
------------------------------------------------------------------
今、あなたが使えるプログラミング言語と好きなところをお書き下さい。
------------------------------------------------------------------
○○言語（中学○年生の頃から）

自己アピール：
------------------------------------------------------------------
あなたのアピールポイントを自由にお書き下さい。（字数・形式無制限）
------------------------------------------------------------------

0. 背景
=======

%
% I. プログラミングコンテストとの出会いについて
%

私は2009年に開催された "パソコン甲子園" という高校生を対象としたプログラミング
コンテストへの参加を契機に "Codeforces" や "Google Code Jam" などオンラインで
定期的に開催されているプログラミングコンテストにしばしば参加しています。
これまでに私がプログラミングコンテストに参加した回数は250回を超えており、
練習で解いた問題を含めると1400問以上のアルゴリズム実装に関する問題を解きました。

私が高校生のときにパソコン甲子園に参加したのは、自分で立ち上げた同好会に
何か活動実績を残すのが目的でしたが、運良く予選を通過することができたため
全国大会に向けて練習をする必要がありました。

それから、ある掲示板サイトで "TopCoder" という海外のプログラミングコンテストが
オンラインで頻繁に開催されているという情報を得て、練習のために過去問を解いて
みることにしました。

英語で書かれた問題文を読み解き、自分の解釈を元に解答の方針を立て、解答となる
ソースコードを書いて提出し、その結果について正解か不正解かを自動的に判定して
もらえるのは、プログラミングの練習というよりも英文読解の練習において非常に
有効であると感じられました。なぜならプログラミング言語という世界共通の言語を
通して、自分の解釈の良し悪しを判断することができるからです。

当時は "Win32" や "DirectX" などの API を利用した Windows アプリケーションの
プログラミングに興味があり、ドキュメントである "MSDN" をよく読んでいました。
しかし、日本語に翻訳されていないコンテンツに当たったときに、英文で書かれている
情報が読めなかったため、英文読解力をつけたいという気持ちを強く持っていました。
そのため、海外のプログラミングコンテストの問題を解き、英語の学習につなげる
ことが、大会以降もプログラミングコンテストに参加し続ける強い動機となりました。


%
% II. プログラミングコンテストにおけるライブラリ事情とその問題点
%

% A. 国内のライブラリ事情

プログラミングコンテストで解答を提出するときは、1つの問題に対して解答となる
1つのソースファイルを提出するという形式が一般的です。また、プログラムを実行して
採点するような形式のプログラミングコンテストでは、一般的に標準ライブラリ以外の
ライブラリファイルの使用は認められていません。そのため、競技者は各自が用意した
ライブラリをコピーしたり直接書き写すことによって1つのソースファイルにまとめる
必要があります。

プログラミングコンテストにおける「ライブラリ」は、テンプレートもしくはスニペット
のように断片的なテキスト形式として利用できる必要があり、一般的なプログラミング
におけるライブラリと比べると、その在り方が限定されているのが特徴です。

日本国内におけるプログラミングコンテスト用のライブラリとして有名なものに
"Spaghetti Source" があります。これは "ICPC" という大学対抗のプログラミング
コンテストで出題される問題を解くために必要な各種アルゴリズムを C++ で実装した
ソースコードを公開しているウェブサイトで、個人が公開しています。

ICPC では、競技中にインターネット上の情報を参考にして問題を解くことは禁止されて
いますが、書籍や印刷物を持ち込んで閲覧することは許可されているため、参加者は
大会で使用するライブラリを事前に紙に印刷して持ち込んでいます。例年、一部の
参加者が大会終了後に各自のライブラリをインターネット上で公開しています。

2009年に発売された "プログラミングコンテストチャレンジブック" という書籍は
プログラミングコンテストで使用する典型的なアルゴリズム実装を例題付きで分かり易く
まとめあげたもので、広く話題となりプログラミングコンテストの知名度を高めました。
この書籍もライブラリとして活用している人を多く見かけます。


% B. 問題点 - テスト手法

上記のライブラリは、いずれも断片的なソースコードのみを公開しているため、テストが
十分になされているのか分からず、信頼性を十分に保証できていません。

これらのライブラリをテストするための手法としては、オンラインジャッジと呼ばれる
プログラミングコンテスト練習用のシステムを使い、それらのライブラリを利用する
問題を解いてソースコードを送信し、正解と判定されるかどうかを確認するという古典的
方法があります。例えば、前述した Spaghetti Source では、検証に利用した問題の
リストが記載されています。

アルゴリズム実装におけるテストは、テストケースを考える部分に難しさがあります。
そのため、オンラインジャッジにある問題集をアルゴリズム実装の信頼性を測るために
利用するのは、問題に不備がある場合を考慮し、複数の問題を使って多角的にテストを
行うことができれば十分に信頼できる適切な方法だと思います。

しかし、実際はそのようにコードを再利用することを考えずに問題を解くため、大抵の
場合は問題を解き直す手間が発生してしまいます。


% C. 問題点 - ライブラリのオープンソースプロジェクト化

個人や少人数によって開発されているプログラミングコンテスト用のライブラリは
上記を含め多数ありますが、オープンソースプロジェクトとしてコミュニティにより
継続的に改善がなされているものはありません。

その要因として「ライブラリを配布するための基盤」が存在しないことが挙げられます。
例えば開発者がライブラリを公開し、ユーザーがそれをダウンロードして各自の環境で
利用することができるような仕組みが整備されていません。

これはプログラミングコンテストのライブラリ事情が特殊であり、テキスト形式の
断片的なソースコードとして配布する必要があること、そしてユーザーごとに異なる
環境でも利用できる形式としてファイルをシステムに展開することが難しいことに
起因していると考えています。


1. 目的
=======

サイボウズ・ラボユースでは大きく2つのシステムを開発したいと思っています。
以下はそれらの簡単な説明とその開発目的など。各システムの詳細（機能概要）は
後述してあります。


%
% I. ソーシャルスニペットシステム
%

各種開発環境やエディタから横断的に利用できるスニペットシステムで、バックエンドの
コマンドライン API とそのフロントエンドである各種環境の拡張機能やプラグインを
開発します。

また、スニペットを配布するためのレジストラは、"GitHub" などの外部サービスを
補助的なインフラとして利用することを考えており、これが「ソーシャルスニペット」
という名前の所以になります。


%
% II. オンラインジャッジの問題をテストケースとして再利用するテストシステム
%

ソーシャルスニペットシステムを使って、テストケースとしてオンラインジャッジの
問題集を利用し、プログラミングコンテスト用のライブラリを自動的にテストするための
仕組みを提供します。


%
% III. 開発目的
%

ソーシャルスニペットシステムはライブラリをスニペットという形式で配布するための
システムです。ここでのスニペットは主に別のソースコードに埋め込むことが可能な
断片的なソースコード、その中でも特にプログラミングコンテストでの利用を想定
したものを指しています。

ソーシャルスニペットシステムでは、スニペットの集まりをリポジトリという単位で
扱います。開発者はライブラリをリポジトリにまとめることでユーザーにライブラリを
配布することができるようになります。逆に、ユーザーはリポジトリを検索して
インストールするだけで各自の環境でライブラリを利用することができます。

このように、ライブラリを公開するときの指針としてソーシャルスニペットを機能させる
ことで、プログラミングコンテストのライブラリ事情を改善する目的があります。

具体的な改善の1つとして、ソーシャルスニペットシステムとオンラインジャッジを
組み合わせることで、プログラミングコンテスト用のライブラリを自動的にテストする
ことができるようになります。

ほかには、オンラインジャッジの豊富な問題集をプログラミングコンテストの練習以外の
目的で活用するという狙いもあります。



2. 概要
=======

%
% I. ソーシャルスニペットシステムについて
%    （開発目標と動作イメージ）
%

% A. 開発の目標

どの環境でも利用できて、エディタやファイルシステムなどに依存しないこと。
また、どのプログラミング言語でも利用できることを目標に開発を進めていきます。


% B. スニペットの挿入機能（相対パス指定）

スニペットファイルの指定はプログラミング言語のコメント機能を利用します。

例えば snip_func という関数を含むソースファイル snip_func.c があり、

```
// snip_func.c
void snip_func() {
  // 処理
}
```


同一のディレクトリに、以下のようなソースファイル code.c があるときは、

```
// code.c
#include <stdio.h>

// @snip <./snip_func.c>

int main() {
  snip_func();
  return 0;
}
```


snip_func.c は code.c に対して以下のように挿入されます。

```
// code.c
#include <stdio.h>

// @snippet <./snip_func.c>
// snip_func.c
void snip_func() {
  // 処理
}

int main() {
  snip_func();
  return 0;
}
```


% C. スニペットの挿入機能（リポジトリ利用）

相対パスによる指定のほか、ローカルにインストールされているリポジトリに含まれる
スニペットを指定することができます。

```
// @snip <repo_name:path/to/file_name>
```

このように記述したときは repo_name リポジトリに含まれる path/to/file_name
ファイルをスニペットとして挿入します。

後述するリポジトリインストール用コマンドを実行して対象となるリポジトリを
ローカルにキャッシュしたあと、キャッシュされたリポジトリにあるファイルから
情報を取得します。


% D. スニペットの挿入機能（リポジトリのバージョン指定）

リポジトリはバージョン情報を持ちます。以下のように記述すると、指定バージョンの
スニペットを挿入することができます。

```
// @snip <repo_name#0.0.1:path/to/file_name>
// @snip <repo_name#1.2.x:path/to/file_name>
```


% E. コマンドライン API

// スニペットの挿入・スニペット間の依存関係解決

    $ snip resolve {file_name}

file_name ファイルに含まれるスニペットをすべて挿入します。挿入するスニペットが
スニペットを持つときはそのスニペットも再帰的に挿入されます。


// リポジトリのインストール

    $ snip install {repo_name}

レジストラに登録されているリポジトリの一覧から、repo_name に一致するリポジトリを
ローカルにインストールします。また、そのリポジトリが依存しているリポジトリも
同時にインストールされます。


// リポジトリの公開（開発者用）

    $ snip publish {URL}

ライブラリ開発者がリポジトリを公開するためのコマンドです。URL には GitHub 
リポジトリなどの URL を記述します。指定した URL にあるリポジトリが、後述する
snippet.json ファイルで指定された名前でレジストラに登録されます。


// リポジトリの検索

    $ snip search {keyword}

keywordにマッチするリポジトリを検索します。


// リポジトリパスの補完

    $ snip complete {keyword}

リポジトリのパスを補完するための情報を取得するコマンドです。


% F. 各種開発環境の拡張機能・プラグイン

フロントエンドは3種類の環境を最初にサポートします。

* Eclipse
* Emacs
* Vim

基本的な共通機能として以下の2機能を実装します。

* コマンドライン API の呼び出し
* スニペットのパスを記述するときの自動補完

環境に依存すると思われる機能では、以下2種類の機能を検討しています。

* リポジトリの管理
  * 各リポジトリに含まれるファイルをツリー形式で表示できる機能
* 対話式のスニペット挿入
  * テンプレート的なスニペットで関数名や変数名を指定できる機能


% G. レジストラについて

リポジトリを配布するためのシステムです。コマンドライン API からの問い合わせを
受ける Web API とブラウザ上でリポジトリの情報を参照できる Web サービスから
構成されます。

これらの機能として、以下のものがあります:

* リポジトリの追加
* リポジトリの削除
* リポジトリ情報の参照
* リポジトリの検索

リポジトリは誰でも追加することができます。追加するリポジトリの所有者である必要は
ありません。誰でも自由に追加することができます。このとき、リポジトリの名前に
ついては早いもの勝ちとなります。

登録されたリポジトリの削除はリポジトリ所有者とレジストラ管理者のみが行える
ものとします。リポジトリの所有者判定については、GitHub の API を利用して確認を
行います。


% H. リポジトリの特殊ファイル: snippet.json

snippet.json はリポジトリにおいて、そのメタ情報（名前やプログラミング言語）を
記述するためのファイルになります。


記述例:

```
{
  "name": "my-snippet",
  "version": "0.0.1",
  "language": "C++",
  "source_dir": "source"
}
```


% I. リポジトリの特殊ファイル: Snipfile

Snipfile は依存するリポジトリやレジストラを記述するためのファイルです。

レジストラを指定すると、そのレジストラが提供する情報を元にリポジトリが
インストールされます。レジストラの指定は以下のように行います:

    source {レジストラのURL}


また、リポジトリの指定は以下のように行います:

    snip {リポジトリ名}, {バージョン指定}


記述例:

```
source "http://url/to/registry"

snip "math", "1.2.3"
snip "geometry", ">=0.0.1"
snip "graph", "3.0.x"
snip "text", "*"
snip "search", "latest"
```



% J. リポジトリのディレクトリ構成例

デフォルトの構成:

```
repo/ （ルート）
 |
 |- snippet.json
 |- Snipfile
 |- file1.c
 -- file2.c
```


snippet.json によってソースコードを配置するディレクトリを変更した場合:

```
repo/ （ルート）
 |
 |- snippet.json
 |- Snipfile
 -- source/ （ソースコード）
     |- file1.c
     -- file2.c
```


% K. キャッシュされたリポジトリのディレクトリ構成例

バージョンごとにファイルを保存します。

```
{ホームディレクトリなど}/.social_snippet/cache/
 |
 -- repo1/
     |
     |- 0.0.1/
     |   |
     |   |- snippet.json
     |   |- Snipfile
     |   -- file1.c
     |
     -- 0.1.1/
         |
         |- snippet.json
         |- Snipfile
         -- new_file1.c
```


% L. 補助的なインフラについて

レジストラは snippet.json ファイルに含まれるリポジトリのメタ情報のみを保持し、
ファイルは GitHub などの外部サービスを利用して配布します。GitHubのように所有者
確認が可能な外部サービスに対応していきます。



%
% II. オンラインジャッジの問題をテストケースとして再利用するテストシステム
%

% A. 目標

なるべく多くのオンラインジャッジに対応し、テスト可能なアルゴリズム実装の幅を
広げ、テストの信頼性を高めていくことを目指します。


% B. 特筆すべき点

このテストシステムにおいて特筆すべき点として、ライブラリのユーザーがそのまま
テスターとなりうるエコシステムが挙げられます。ユーザーは普段と同じように
ライブラリを利用して問題を解くだけで、そのコードをテストコードとして開発者に
提供することが可能となります。


% C. このシステムを利用してライブラリをテストするときの流れ

1. テストしたいライブラリ（ソーシャルスニペット形式）を使い、
   通常と同じようにオンラインジャッジの問題を解く
2. ソースコードをスニペットを挿入する前の状態に戻す
3. ライブラリのテストコードとオンラインジャッジの問題IDを紐付ける
4. スニペットの挿入を実行し、オンラインジャッジに挿入後のソースコードを送信
5. オンラインジャッジによる正誤判定の結果をテスト結果として表示
6. 指定されたすべての問題に正解できたらテストが成功したとみなす


% D. 課題: オンラインジャッジを匿名で利用できるようにする必要がある

このシステムでは、実際にテストコードをオンラインジャッジへ提出し、テストの実行と
正誤判定をオンラインジャッジに委ね、その結果を集約することでテストを行います。

基本的にオンラインジャッジというのは登録制のシステムで、認証を行わずにシステムを
利用できるオンラインジャッジは一般的ではありません。そのため、このシステムを
実現するには各オンラインジャッジに対応を依頼する必要があります。

ユーザーにオンラインジャッジのアカウントを取得してもらい、認証情報を各自で
設定してもらうことも出来ますが、"Travis CI" や "Circle CI" のような継続的
インテグレーション用のサービスを利用する場合を考えると、余計な認証情報を
ユーザーが設定することなく実行できるようにしたいと考えています。

幸いなことに、私が所属している研究室では "Aizu Online Judge"（通称 AOJ）という
オンラインジャッジを開発しており、必要となる変更を私自身が担当して行うことが
できます。AOJ は10年近い稼働実績があるほか、収録問題数も国内では最大規模であり、
システムのサポート対象としても申し分ありません。

AOJ 以外のオンラインジャッジへ対応を広げるための戦略として、まず AOJ への対応
によって実用性を示したうえで、国内の他オンラインジャッジに協力を依頼し、最終的に
海外のオンラインジャッジへと対応を展開していくことを考えています。


% E. AOJ を匿名提出機能に対応させる場合

AOJ に専用の Web API を追加することで、匿名によるソースコードの提出に
対応させます。既存の提出機能との違いは以下の3つです:

* 認証情報が不要であること
* 正誤判定後に解答ステータスだけを何らかの形式（XMLやJSONなど）で返すこと
* コード提出後に正解数ランキング等の情報に影響を与えないこと

他オンラインジャッジにも同様の提案を行いますが、この機能への対応については
オンラインジャッジに導入する直接的なメリットが思いつかないため、対応を広げるには
何らかの形でオンラインジャッジに還元できる方法を探ることが課題となります。


% F. 対応する候補として考えているオンラインジャッジシステム

以下に挙げたシステム以外にも多くのオンラインジャッジが存在しますが、
ここではフットワークの軽そうなオンラインジャッジを候補として挙げています。


// 国内のオンラインジャッジ

* Aizu Online Judge
  * ICPC の過去問題などが収録されています
  * 問題数: 1389問

* AtCoder
  * 定期的にプログラミングコンテストを開催しています
  * 問題数: 約300問（過去に開催されたコンテスト1回あたり4問として概算）

* NPCA Judge
  * 灘校パソコン研究部が開発しているオンラインジャッジです
  * 問題数: 約200問（問題IDから概算）


// 海外のオンラインジャッジ

* Sphere Online Judge
  * ポーランドのオンラインジャッジです
  * 問題数: 4952問（ウェブサイト上で公表されている問題数）

* Codeforces
  * ロシアのプログラミングコンテストです
  * 問題数: 約1250問（過去に開催されたコンテスト1回あたり5問として概算）


% G. 各種テストフレームワークへの対応

各種テストフレームワークの拡張機能を提供することで、様々なプログラミング言語で
テストコードとオンラインジャッジの問題を対応付けることができます。

具体的には Ruby のテストフレームワークである "RSpec" への対応などを考えており、
以下のようにテストの実行を記述できるようにしたいと考えています。

```
context :tested_library do
  before do
    snip_mock "tested_library", "../source_dir"
  end
  context :tested_func1 do
    it { aoj "1234", "test_1234.c" }
    it { aoj "777", "test_777.c" }
  end
end
```

上記のテストコードは、tested_library というライブラリに含まれる tested_func1
という関数をテストするために、 AOJ の問題番号 1234 に対して "test_1234.c" という
ファイルを、問題番号 777 に対して "test_777.c" というファイルを解答コードとして
送信することを表しています。

解答を送信する直前にスニペットの挿入が行われますが、ここでは snip_mock という
命令によって、tested_library というリポジトリのディレクトリパスを直接指定し
テスト対象となる開発版のスニペットコードが挿入されるように設定しています。






過去に作成したソフトウェア：
------------------------------------------------------------------
今までどのようなソフトウェアを作成したか自由にお書きください。
------------------------------------------------------------------
GitHubのURLなど：
